/**
 * The World class controlls the different parts of the application and contains the whole 
 * information about the game.
 */
class World {
  /* Attributs: */

  canvas;
  keyboard;
  level = {};
  character = {};

  /**
   * Array of all throwable objects currently contained in the world.
   * @type {Array}
   */
  throwableObjects = [];

  /** 
   * Array of all StatusBar objects needed in the world. 
   * @type {Array}
   */
  statusBars = [
    new StatusBar('health', 100),
    new StatusBar('coins', 0),
    new StatusBar('bottles', 0)
  ];

  /**
   * If true the next bottle can be thrown. It is set to false after D is pressed (keydown event) by the 
   * user and is again set to be true, after the user stops pressing D (keyup event).
   * @type {boolean}
   */
  throwNextBottle = true;

  /** 
   * x-position of canvas relative to which all objects are painted, which are not static
   * and move along side the character during the game. The creates the illusion of the 
   * camera moving, when the character is moving.
   * @type {number}
   */
  cameraX = 0;

  /**
   * Array of Arrays containing two objects. The first one is a function expression and the second 
   * one is a time in ms. Example: [[() => {this.x += 1}, 10], [() => {this.y += 3}, 10],...]
   * @type {Array}
   */
  loopArray = [];

  /** 
   * Current frame number, which is used to measure time during the game.
   * @type {number}
   */
  frame = 0;

  /**
   * Setting this value to true, will freeze the entire game until it is again set to false.
   * @type {boolean}
   */
  freeze = false; 

  /**
   * Contains the frame at which the game was frozen to restore the frame number when the game is 
   * continued.
   * @type {number}
   */
  saveFrameNumber;

  /**
   * Is set to true, after the game loaded for 1s. This is done in the game.js file.
   * @type {boolean}
   */
  gameReady = false;

  /**
   * Is set to true after the game is started by the user by pressing SPACE.
   * @type {boolean}
   */
  gameStarted = false;

  /**
   * When the character dies this variable is set to true, which indicates that the game was lost.
   * @type {boolean}
   */
  gameOver = false;

  /**
   * When the endboss dies this variable is set to true, which indicates that the game was won.
   * @type {boolean}
   */
  gameWon = false;

  gameWonSoundAlreadyPlayed = false;
  gameOverSoundAlreadyPlayed = false;

  /**
   * This is set to true, when the user restarts the game. In this case the loop of the game, 
   * generated by the requestAnimationFrame, is stopped forever for the corresponding world.
   */
  gameDelete = false;

  /**
   * This value contains the number of requestAnimation frames generated per second. This 
   * depends on the hardware of the user. In the current implementation it is set to 100, which is 
   * fine for normal desktop computers. In the future this value should be automatically computed
   * such that it is finetuned to the hardware of the user. Implementation will follow in the future.
   * @type {number}
   */
  framesPerSecond;

  milliSecondPerFrame;

  SOUND_GAME_MUSIC = new Audio('audio/game-music.mp3');
  SOUND_GAME_WIN = new Audio('audio/win.mp3');
  SOUND_GAME_OVER = new Audio('audio/gameover.mp3');

  /* Methods:*/


  /**
   * @param {Canvas} canvas 
   * @param {Keyboard} keyboard 
   */
  constructor(canvas, keyboard) {
    /* Construct World Object: */
    this.framesPerSecond = 100; // Dies muss noch irgendwie berechnet werden, da die Dauer 
    // eines Frames bei der Verwendung von requestAnimationFrame() von der Graphikkarte des
    // Users abhÃ¤ngt. 
    this.canvas = canvas;
    this.keyboard = keyboard;
    this.milliSecondPerFrame = 1 / (this.framesPerSecond / 1000);
    /* Add first Elements to Loop to apply the fundamental game logic: */
    this.addToLoopArray(() => {this.applyGameLogic()}, 10);
    this.setSoundProperties();
  }

  /**
   * Starts the game by starting the loop function, which then calls itself after each animation frame.
   */
  startGame() {
    this.loop();
    this.playGameSound();
    this.gameStarted = true;
    this.showPauseButton()
    
  }


  showPauseButton() {
    document.getElementById('icons-div').style = 'display: unset;';
  }


  hidePauseButton() {
    document.getElementById('icons-div').style = 'display: none;';
  }


  pauseGame() {
    this.freeze = true;
    this.pauseGameSound();
  }


  restartGame() {
    this.freeze = false;
    this.playGameSound();
  }

  
  playGameSound() {
    this.SOUND_GAME_MUSIC.play();
  }

  
  pauseGameSound() {
    this.SOUND_GAME_MUSIC.pause();
    this.character.WALKING_SOUND.pause();
    this.level.enemies.forEach((chicken) => {
      if (chicken instanceof Chicken || chicken instanceof YellowChicken){
        chicken.SOUND_CHICKEN.pause();
        chicken.SOUND_CHICKEN_KILL.pause();
      }
    });
  }


  setSoundProperties() {
    this.SOUND_GAME_MUSIC.loop = true;
    this.SOUND_GAME_MUSIC.volume = 0.05;
    this.SOUND_GAME_WIN.volume = 0.3;
    this.SOUND_GAME_OVER.volume = 0.3;
  }


  /**
   * Adds an additional array to the LoopArray property of the world object.
   * @param {function} callback Functionexpression which should be called 
   * after the timeInterval in a loop.
   * @param {number} timeInterval Timeinterval in ms after which the callback is called.
   */
  addToLoopArray(callback, timeInterval) {
    let frameInterval = Math.floor(timeInterval / this.milliSecondPerFrame) // floor rounds numbers down
    // This is necessary for using Modulo!
    this.loopArray.push([callback, frameInterval]);
  }


  /**
   * Applies the Elements of the loopArray by calling the callback function after the specified
   * number of frames in the loop. This updates the model information about the 
   * objects of the game before they are painted onto the canvas. 
   */
  update() {
    if(this.freeze) return;
    this.loopArray.forEach((element) => {
      if (this.frame % element[1] === 0) element[0]();
    });
  }


  /**
   * Generates an endless loop using the requestAnimationFrame method. Each loop of this function
   * defines a frame of the game. Using the update() method the information about the model objects 
   * is changed in the correct way defined in the Looparray attribute. After that all model objects 
   * are painted to the canvas using the draw() method.
   */
  loop() {
    if (this.gameDelete) return;
    this.update();
    this.draw();
    this.nextFrame();
    requestAnimationFrame(() => { this.loop(); });
  }

  /**
   * Generates the next frame number by adding one or restoring the old framenumber, if the game 
   * is restarted after it was frozen. If the game is frozen the framenumber is saved in the 
   * corresponding attribute saveFrameNumber of the world.
   */
  nextFrame() {
    if(this.freeze){
      this.saveFrameNumber = this.frame;
    }
    else if (this.saveFrameNumber){
      this.frame = this.saveFrameNumber;
      this.saveFrameNumber = undefined;
    }
    else {
      this.frame++;
    }
  }


  /**
   * Draws all objects currently contained in the world in the canvas. Furthermore it generates the
   * corresponding endscreen.
   */
  draw() {
    this.canvas.clear();
    this.canvas.drawObjectArray(this.level.backgroundObjects, this.cameraX);
    this.canvas.drawObjectArray(this.level.clouds, this.cameraX);
    this.canvas.drawObjectArray(this.level.enemies, this.cameraX);
    this.canvas.drawObject(this.character, this.cameraX);
    this.canvas.drawObjectArray(this.throwableObjects, this.cameraX);
    this.canvas.drawObjectArray(this.statusBars, 0);
    this.canvas.drawObjectArray(this.level.collectableObjects, this.cameraX);
    this.showGameOverScreen();
    this.showWonScreen();
    // Debugging: ###################################################################################
    //this.drawHitBoxes();

  }


  generateEndScreen(path) {
    let gameOverScreen = new DrawableObject();
    gameOverScreen.x = 0;
    gameOverScreen.y = 0;
    gameOverScreen.width = canvas.width;
    gameOverScreen.height = canvas.height;
    gameOverScreen.loadImage(path);
    return gameOverScreen;
  }


  /**
   * Draws the GameOver Screen into the canvas and plays the GameOver sound.
   */
  showGameOverScreen() {
    if(!world.gameOver) return; 
    this.canvas.drawObject(this.generateEndScreen('img/9.Intro _ Outro Image/_Game over_ screen/1.you lost.png'), 0);
    this.canvas.drawText('Press SPACE to play again...', world.canvas.width/2, 440, 0);
    this.pauseGame();
    if(this.gameOverSoundAlreadyPlayed) return;
    this.SOUND_GAME_OVER.play();
    this.gameOverSoundAlreadyPlayed = true;
    this.hidePauseButton();
  }


  /**
   * Draws the GameWon Screen into the canvas and plays the GameWon sound.
   */
  showWonScreen() {
    if(!world.gameWon) return;
    this.canvas.drawObject(this.generateEndScreen('img/9.Intro _ Outro Image/_Game over_ screen/3.Game over.png'), 0);
    this.canvas.drawText('Press SPACE to play again...', world.canvas.width/2, 440, 0);
    this.pauseGame();
    if(this.gameWonSoundAlreadyPlayed) return;
    this.SOUND_GAME_WIN.play();
    this.gameWonSoundAlreadyPlayed = true;
    this.hidePauseButton();
  }


  /**
   * Draws the hit-Box and attack-Box object of each object into the canvas. This is only used for debugging.
   */
  drawHitBoxes() {
    this.canvas.drawBox(this.character.hitBox, this.cameraX);
    this.canvas.drawBox(this.character.attackBox, this.cameraX);

    if (!this.level.enemies) return;
    this.level.enemies.forEach((enemy) => {
      this.canvas.drawBox(enemy.hitBox, this.cameraX);
      this.canvas.drawBox(enemy.attackBox, this.cameraX);
    });

    if (!this.level.collectableObjects) return;
    this.level.collectableObjects.forEach((collectable) => {
      this.canvas.drawBox(collectable.hitBox, this.cameraX);
    });

    if (!this.throwableObjects) return;
    this.throwableObjects.forEach((throwable) => {
      this.canvas.drawBox(throwable.attackBox, this.cameraX);
    });

  }


  updateStatusBars() {
    this.statusBars[0].setPercentage(this.character.health);
    this.statusBars[1].setPercentage(this.character.coins);
    this.statusBars[2].setPercentage(this.character.bottles * 4); // For each bottle the
    // percentage value should increase by 4.
  }


  /**
   * Combines all the functions needed to apply the game logic in one function.
   */
  applyGameLogic() {
    this.checkThrowBottle();
    this.collectBottles();
    this.removeInActiveObjects();
    this.enemyAttackedByCharacter();
    this.characterAttackedByEnemy();
    this.enemyAttackByBottle();
    this.checkGameWon();
    this.checkGameOver();
  }


  checkGameOver() {
    if(!this.character.isDead()) return;
    this.gameOver = true;
  }


  checkGameWon() {
    if(!this.level.enemies[0].isDead()) return;
    // Here we wait 1s to see the full dead animation of the endboss.
    setTimeout(() => {
      this.gameWon = true;
    }, 1000);
    
  }


  /**
   * Checks if character is attacked by an enemy.
   */
  characterAttackedByEnemy() {
    if (!this.level.enemies) return;
    if (!this.character.damage) return;

    this.level.enemies.forEach((enemy) => {
      if (this.character.isAttackBy(enemy)) {
        this.character.getDamage(enemy.damage);
        enemy.frameLastDamageDeal = this.frame;
        this.updateStatusBars();
      }
    });
  }

  /**
   * Checks if enemy is attacked by the character.
   */
  enemyAttackedByCharacter() {
    if (!this.level.enemies) return;
    if (!this.character.damage) return;

    this.level.enemies.forEach((enemy) => {
      if (enemy.isAttackBy(this.character) && !enemy.isAboveGround()) {
        enemy.getDamage(this.character.damage);
        this.character.frameLastDamageDeal = this.frame;
        this.updateStatusBars();
      }
    });
  }


  /**
   * Checks if enemy was attack by a bottle.
   */
  enemyAttackByBottle() {
    if (!this.level.enemies) return;
    if (!this.character.damage) return;
    if (!this.throwableObjects) return;

    this.throwableObjects.forEach((bottle) => {
      this.level.enemies.forEach((enemy) => {
        if (enemy.isAttackBy(bottle) && !bottle.isSplashed && !enemy.isDead()) {
          enemy.getDamage(bottle.damage);
          bottle.isSplashed = true;
          bottle.frameLastDamageDeal = this.frame;
          this.updateStatusBars();
        }
      });
    });
  }


  /**
   * Checks if the user pressed the button D on the keyboard. If this is true a new bottle 
   * object is added to the game.
   */
  checkThrowBottle() {
    if (this.keyboard.D && this.character.bottles > 0 && this.throwNextBottle) {
      let bottle = new Bottle(this.character.x + 100, this.character.y + 100);
      this.throwableObjects.push(bottle);
      this.throwNextBottle = false;
      this.character.bottles--;
      this.keyboard.D = false;
      this.updateStatusBars();
    }
  }

  /**
   * Checks if an CollectableObject object was collected by the character. Then it applies its 
   * effects and removes it from the game. 
   */
  collectBottles() {
    if (!this.level.collectableObjects) return;
    this.level.collectableObjects.forEach((object) => {
      if (this.character.hitBox.isColliding(object.hitBox)) {
        object.collectByCharacter();
        this.updateStatusBars();
      }
    });
  }


  /**
   * Remove inactive Objects from the game.
   */
  removeInActiveObjects() {
    // Remove inactiv CollectableObject objects:
    this.level.collectableObjects = this.removeCollectableObjects(this.level.collectableObjects);
    this.throwableObjects = this.removeThrowableObjects(this.throwableObjects);
  }


  /**
   * Remove all inactive CollectableObject objects.
   * @returns Array of activ collectable Objects
   */
  removeCollectableObjects() {
    if (!this.level.collectableObjects) return;
    let result = [];
    this.level.collectableObjects.forEach((object) => {
      if (object.activ) result.push(object);
    });
    return result;
  }


  /**
   * Remove all inactive throwable objects.
   * @returns Array of activ throwable Objects
   */
  removeThrowableObjects() {
    let result = [];
    this.throwableObjects.forEach((object) => {
      if (object.activ) result.push(object);
    });
    return result;
  }

}